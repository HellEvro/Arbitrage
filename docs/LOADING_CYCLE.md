# Полный цикл загрузки и работы системы Arbitrage Bot

## 📋 Обзор

Документ описывает полный цикл загрузки всех модулей, инициализации компонентов, запуска циклов и параллельных задач в системе арбитражного бота.

---

## 🚀 Этап 1: Точка входа (`main.py`)

### 1.1 Импорт модулей и настройка логирования
```python
# Импортируются все необходимые модули:
- arbitrage_bot.bootstrap (build_app_components)
- arbitrage_bot.config (load_settings)
- arbitrage_bot.core.app_runner (AppRunner)
- arbitrage_bot.core.port_cleanup (cleanup_port)
- arbitrage_bot.web (create_app)
```

**Действия:**
- Настраивается базовое логирование (уровень INFO)
- Создается логгер `arbitrage_bot.system`

### 1.2 Функция `main()` - асинхронная точка входа

**Последовательность выполнения:**

1. **Загрузка настроек** (`load_settings()`)
   - Читается конфигурация из `config.yaml` или `config/config.yaml`
   - Валидируется через Pydantic модели
   - Возвращается объект `Settings`

2. **Очистка порта** (`cleanup_port()`)
   - Проверяется занятость порта из конфигурации
   - Убиваются процессы Python, занимающие порт
   - До 3 попыток с задержкой 2 секунды между попытками
   - **БЛОКИРУЮЩАЯ операция** - система не продолжит работу, если порт занят

3. **Построение компонентов** (`build_app_components()`)
   - **См. Этап 2**

4. **Создание веб-приложения** (`create_app()`)
   - **См. Этап 3**

5. **Создание и запуск AppRunner**
   - **См. Этап 4**

6. **Ожидание завершения** (`runner.wait()`)
   - Ожидает сигнала остановки (`_stop_event`)

7. **Очистка при завершении**
   - Останавливается `runner`
   - Закрываются все адаптеры бирж
   - Закрывается `http_factory`

---

## 🔧 Этап 2: Построение компонентов (`bootstrap.py`)

### 2.1 Функция `build_app_components()`

**Последовательность инициализации:**

1. **Загрузка настроек** (`load_settings()`)
   - Повторная загрузка (уже была в main.py, но это нормально)
   - Валидация конфигурации

2. **Настройка логирования** (`configure_logging()`)
   - Настраиваются логгеры для каждого модуля
   - Уровни логирования из конфигурации

3. **Создание HTTP фабрики** (`HttpClientFactory()`)
   - Создается фабрика для HTTP-клиентов
   - Настраивается таймаут (10 секунд)
   - User-Agent для запросов

4. **Создание адаптеров бирж** (`create_adapters()`)
   - Для каждой биржи из `settings.exchanges` создается адаптер:
     - `BybitAdapter`
     - `MexcAdapter`
     - `BitgetAdapter`
     - `OkxAdapter`
     - `KucoinAdapter`
   - Каждый адаптер получает `http_factory` и `poll_interval=1.0`
   - **ПАРАЛЛЕЛЬНО создаются все адаптеры** (синхронно, но независимо)

5. **Создание MarketDiscoveryService**
   - Передаются все адаптеры
   - `refresh_interval_sec = 300.0` (5 минут)

6. **Создание QuoteStore**
   - Хранилище котировок (in-memory)
   - **Два словаря:** `_quotes_write` (для записи) и `_quotes_read` (для чтения)
   - **Атомарное переключение:** запись не блокирует чтение!

7. **Создание FeeFetcher**
   - Автоматическое получение комиссий с бирж
   - **АСИНХРОННАЯ операция:** `await fee_fetcher.refresh_all(settings.exchanges)`
   - Запрашивает комиссии для всех бирж

8. **Создание ArbitrageEngine**
   - Передаются `quote_store`, `settings`, `fee_fetcher`

9. **Создание TelegramNotifier**
   - Уведомления в Telegram (если настроено)

10. **Первичное обновление рынков** (`discovery.refresh()`)
    - **АСИНХРОННАЯ операция:** запрашивает рынки со всех бирж
    - **ПАРАЛЛЕЛЬНО:** `asyncio.gather()` запрашивает рынки со всех бирж одновременно
    - Находит пересечения (символы, доступные на ≥2 биржах)
    - Возвращает список `MarketInfo`

11. **Создание QuoteAggregator**
    - Передаются адаптеры, `quote_store`, и найденные рынки
    - Строятся маппинги символов (`_rebuild_mappings()`)
    - Инициализируется статус для каждой биржи

**Возвращаемые компоненты:**
```python
return (
    settings,
    http_factory,
    adapters,          # список адаптеров
    discovery,         # MarketDiscoveryService
    quote_store,       # QuoteStore
    aggregator,        # QuoteAggregator
    arbitrage_engine,  # ArbitrageEngine
    notifier,          # TelegramNotifier
)
```

---

## 🌐 Этап 3: Создание веб-приложения (`web/app.py`)

### 3.1 Функция `create_app()`

**Последовательность:**

1. **Создание Flask приложения**
   - Инициализация Flask с шаблонами и статикой

2. **Создание SocketIO**
   - Режим: `threading` (отдельный поток)
   - CORS настройки из конфигурации
   - `allow_unsafe_werkzeug=True`

3. **Регистрация маршрутов:**
   - `GET /api/status` - статус системы
   - `GET /api/ranking` - список арбитражных возможностей
   - `GET /api/exchange-status` - статус бирж
   - `GET /` - главная страница
   - `GET /internal/markets` - список рынков
   - `POST /internal/quote` - добавление котировки (для тестирования)
   - `GET /internal/telegram/status` - статус Telegram
   - `POST /internal/telegram/toggle` - включение/выключение Telegram

4. **WebSocket обработчики:**
   - `@socketio.on("connect")` - отправка начальных данных при подключении
   - `emit_loop()` - **ФОНОВЫЙ ЦИКЛ** для отправки обновлений через WebSocket
     - Запускается через `socketio.start_background_task(emit_loop)`
     - **ОТДЕЛЬНЫЙ ПОТОК:** работает в фоновом потоке Flask-SocketIO
     - Цикл: каждую секунду получает данные и отправляет клиентам
     - Использует кэш при таймаутах

**Возвращает:** `(app, socketio)`

---

## ⚙️ Этап 4: Запуск AppRunner (`core/app_runner.py`)

### 4.1 Инициализация AppRunner

**Компоненты:**
- `_settings` - настройки
- `_aggregator` - QuoteAggregator
- `_engine` - ArbitrageEngine
- `_discovery` - MarketDiscoveryService
- `_notifier` - TelegramNotifier
- `_app` - Flask приложение
- `_socketio` - SocketIO
- `_stop_event` - событие остановки
- `_tasks` - список задач asyncio

### 4.2 Метод `start()` - запуск всех компонентов

**Последовательность:**

1. **Настройка обработчиков сигналов** (`setup_signal_handlers()`)
   - Обработка `SIGINT`, `SIGTERM` для graceful shutdown
   - Устанавливает `_stop_event` при получении сигнала

2. **Запуск QuoteAggregator** (`aggregator.start()`)
   - **См. Этап 5**

3. **Создание параллельных задач:**
   ```python
   # Задача 1: Цикл оценки арбитража
   self._tasks.append(
       asyncio.create_task(self._evaluation_loop(), name="evaluation-loop")
   )
   
   # Задача 2: Цикл обновления рынков
   self._tasks.append(
       asyncio.create_task(self._discovery_loop(), name="discovery-loop")
   )
   
   # Задача 3: Flask сервер
   self._tasks.append(
       asyncio.create_task(self._run_flask_server(), name="flask-server")
   )
   ```

### 4.3 Цикл оценки арбитража (`_evaluation_loop()`)

**Параметры:**
- Интервал: **1 секунда** (`await asyncio.sleep(1)`)

**Логика:**
```python
while not self._stop_event.is_set():
    # 1. Получить арбитражные возможности
    opportunities = await self._engine.evaluate()
    
    # 2. Отправить уведомления (неблокирующе, таймаут 0.5 сек)
    await asyncio.wait_for(self._notifier.notify(opportunities), timeout=0.5)
    
    # 3. Логирование
    log.info("Evaluation loop iteration %d: found %d opportunities", ...)
    
    # 4. Пауза 1 секунда
    await asyncio.sleep(1)
```

**Особенности:**
- Работает **ПОСТОЯННО** в отдельной asyncio задаче
- Обрабатывает ошибки и продолжает работу
- Не блокирует другие задачи

### 4.4 Цикл обновления рынков (`_discovery_loop()`)

**Параметры:**
- Интервал: **300 секунд** (5 минут) - `self._discovery.refresh_interval`

**Логика:**
```python
while not self._stop_event.is_set():
    # 1. Обновить список рынков
    markets = await self._discovery.refresh()
    
    # 2. Обновить агрегатор новыми рынками
    await self._aggregator.refresh_markets(markets)
    
    # 3. Пауза 5 минут
    await asyncio.sleep(self._discovery.refresh_interval)
```

**Особенности:**
- Работает **ПЕРИОДИЧЕСКИ** в отдельной asyncio задаче
- При обновлении рынков перезапускает QuoteAggregator

### 4.5 Flask сервер (`_run_flask_server()`)

**Логика:**
```python
def run_socketio():
    # Запуск Flask-SocketIO в отдельном потоке
    self._socketio.run(
        self._app,
        host=settings.web.host,
        port=settings.web.port,
        allow_unsafe_werkzeug=True,
        use_reloader=False,
    )

# Создание потока
flask_thread = threading.Thread(target=run_socketio, daemon=True)
flask_thread.start()

# Открытие браузера через 1.5 секунды
asyncio.create_task(open_browser())

# Ожидание события остановки
await self._stop_event.wait()
```

**Особенности:**
- Flask-SocketIO работает в **ОТДЕЛЬНОМ ПОТОКЕ** (daemon thread)
- WebSocket emit loop работает в **ФОНОВОМ ПОТОКЕ** Flask-SocketIO
- Браузер открывается автоматически через 1.5 секунды

---

## 📊 Этап 5: Запуск QuoteAggregator (`services/quote_aggregator.py`)

### 5.1 Метод `start()` - запуск агрегатора

**Последовательность:**

1. **Проверка активных бирж**
   - Минимум 2 биржи должны иметь символы
   - Предупреждение, если меньше

2. **Создание очередей:**
   - `_quote_queue` - asyncio.Queue для котировок (maxsize=10000)
   - `_mexc_thread_queue` - threading.Queue для MEXC (maxsize=5000) - если есть MEXC

3. **Запуск воркеров:**

   **a) Воркер переноса MEXC котировок** (`_transfer_mexc_quotes()`)
   - **ОТДЕЛЬНАЯ asyncio задача**
   - Переносит котировки из `threading.Queue` в `asyncio.Queue`
   - Работает пакетами по 10 котировок
   - Ограничение времени: максимум 50мс на итерацию
   - Освобождает event loop каждые 50 котировок

   **b) Воркер обработки котировок** (`_process_quotes_worker()`)
   - **ОТДЕЛЬНАЯ asyncio задача**
   - Берет котировки из `_quote_queue`
   - **Обрабатывает пакетами по 1000 котировок** - MEXC получает все данные сразу!
   - **БЕЗ ограничений по времени** - обрабатывает все котировки за один такт
   - **БЕЗ ограничений на MEXC** - обрабатывает все котировки от MEXC сразу
   - Пакетно обновляет `QuoteStore` (все котировки за один раз)
   - Обновляет статусы бирж

   **c) Воркеры бирж** (`_exchange_worker()`)
   - **ОТДЕЛЬНАЯ asyncio задача для каждой биржи**
   - Для MEXC: **ОТДЕЛЬНЫЙ ПОТОК** (threading.Thread)
     - Создается отдельный event loop для потока
     - Создается отдельный `HttpClientFactory` для потока
     - Создается отдельный `MexcAdapter` для потока
     - Получает котировки и кладет в `threading.Queue`
   - Для остальных бирж: обычная asyncio задача
     - Использует `adapter.quote_stream(symbols)`
     - Кладет котировки в `asyncio.Queue`

### 5.2 Цикл получения котировок (`_exchange_worker()`)

**Для обычных бирж (не MEXC):**
```python
while not adapter.closed:
    try:
        async for quote in adapter.quote_stream(symbols):
            # Кладем котировку в очередь (неблокирующе)
            self._quote_queue.put_nowait((exchange_name, quote))
    except Exception:
        # Обработка ошибок, повтор через 5 секунд (или 10 для 403)
        await asyncio.sleep(retry_delay)
```

**Для MEXC:**
- Работает в **ОТДЕЛЬНОМ ПОТОКЕ**
- Создает свой event loop
- Получает котировки и кладет в `threading.Queue`
- Воркер переноса переносит их в `asyncio.Queue`

### 5.3 Цикл обработки котировок (`_process_quotes_worker()`)

**Логика:**
```python
while True:
    # 1. Собрать пакет котировок (максимум 1000, БЕЗ ограничений по времени!)
    batch = []
    while len(batch) < batch_size:  # batch_size = 1000
        exchange_name, quote = await self._quote_queue.get(timeout=0.01)
        # БЕЗ ограничений на MEXC - обрабатываем все котировки!
        batch.append((exchange_name, quote))
    
    # 2. Обработать пакет БЕЗ задержек:
    #    - Маппинг символов
    #    - Вычисление mid_price
    #    - Сбор обновлений для QuoteStore
    
    # 3. Пакетно обновить QuoteStore (ВСЕ котировки за один раз!)
    await self._quote_store.upsert_batch(updates)  # Все сразу!
    
    # 4. Обновить статусы бирж
    async with self._status_lock:
        # Обновление статусов...
```

**Особенности:**
- Работает **ПОСТОЯННО** в отдельной asyncio задаче
- Обрабатывает котировки пакетами по **1000 за такт** для максимальной эффективности
- **БЕЗ ограничений на MEXC** - MEXC получает все данные сразу из массива API
- **БЕЗ задержек** - обрабатывает все котировки максимально быстро

---

## 🔄 Этап 6: Циклы получения котировок (адаптеры бирж)

### 6.1 Метод `quote_stream()` в адаптерах

**Пример: BybitAdapter**

```python
async def quote_stream(self, symbols: Sequence[str]) -> AsyncIterator[ExchangeQuote]:
    watched = {symbol.upper() for symbol in symbols}
    
    while not self.closed:
        # 1. Запрос к API биржи
        data = await self._http.get_json(
            f"{self._REST_BASE}/v5/market/tickers",
            params={"category": "spot"},
        )
        
        # 2. Парсинг ответа
        entries = data.get("result", {}).get("list", [])
        
        # 3. Фильтрация по watched symbols
        for item in entries:
            symbol = item.get("symbol", "").upper()
            if symbol not in watched:
                continue
            
            # 4. Создание ExchangeQuote
            yield ExchangeQuote(...)
        
        # 5. Пауза (poll_interval = 1.0 секунда)
        await self.wait_interval()
```

**Особенности:**
- Каждый адаптер работает **НЕЗАВИСИМО** в своем воркере
- Интервал опроса: **1 секунда** для всех бирж
- Использует `HttpClientFactory` для HTTP запросов
- Обрабатывает ошибки и повторяет запросы

---

## 📈 Параллельные задачи и потоки

### Схема параллельности:

```
┌─────────────────────────────────────────────────────────────┐
│                    Main Event Loop (asyncio)                │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Task 1: evaluation_loop()                           │   │
│  │  - Интервал: 1 секунда                               │   │
│  │  - Вызывает engine.evaluate()                        │   │
│  │  - Отправляет уведомления                            │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Task 2: discovery_loop()                            │   │
│  │  - Интервал: 300 секунд (5 минут)                    │   │
│  │  - Обновляет список рынков                           │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Task 3: flask_server()                              │   │
│  │  - Запускает Flask в отдельном потоке                │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  QuoteAggregator Tasks:                              │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: transfer_mexc_quotes()                │   │   │
│  │  │  - Переносит котировки MEXC                  │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: process_quotes_worker()               │   │   │
│  │  │  - Обрабатывает котировки из очереди         │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: exchange_worker(Bybit)                │   │   │
│  │  │  - Получает котировки с Bybit                │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: exchange_worker(Okx)                   │   │   │
│  │  │  - Получает котировки с Okx                  │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: exchange_worker(Bitget)              │   │   │
│  │  │  - Получает котировки с Bitget              │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌──────────────────────────────────────────────┐   │   │
│  │  │  Task: exchange_worker(Kucoin)              │   │   │
│  │  │  - Получает котировки с Kucoin              │   │   │
│  │  └──────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│              Threading (отдельные потоки)                   │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Thread: Flask-SocketIO Server                       │   │
│  │  - Обрабатывает HTTP запросы                         │   │
│  │  - Обрабатывает WebSocket соединения                 │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Thread: Flask-SocketIO emit_loop()                 │   │
│  │  - Отправляет обновления через WebSocket            │   │
│  │  - Интервал: 1 секунда                              │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Thread: MEXC Worker (если есть MEXC)              │   │
│  │  - Свой event loop                                   │   │
│  │  - Получает котировки с MEXC                        │   │
│  │  - Кладет в threading.Queue                         │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔄 Полный цикл работы системы

### Временная диаграмма:

```
T=0s:    Запуск main()
         ├─ Загрузка настроек
         ├─ Очистка порта
         ├─ build_app_components()
         │   ├─ Загрузка настроек
         │   ├─ Создание HTTP фабрики
         │   ├─ Создание адаптеров
         │   ├─ Создание сервисов
         │   ├─ fee_fetcher.refresh_all() [ASYNC, PARALLEL]
         │   └─ discovery.refresh() [ASYNC, PARALLEL - все биржи одновременно]
         ├─ create_app()
         │   ├─ Создание Flask
         │   ├─ Создание SocketIO
         │   └─ Регистрация маршрутов
         └─ AppRunner.start()
             ├─ setup_signal_handlers()
             ├─ aggregator.start()
             │   ├─ Создание очередей
             │   ├─ Запуск transfer_mexc_quotes() [TASK]
             │   ├─ Запуск process_quotes_worker() [TASK]
             │   └─ Запуск exchange_worker() для каждой биржи [TASKS]
             │       └─ Для MEXC: запуск отдельного потока [THREAD]
             ├─ Запуск evaluation_loop() [TASK]
             ├─ Запуск discovery_loop() [TASK]
             └─ Запуск flask_server() [TASK]
                 └─ Запуск Flask в потоке [THREAD]
                     └─ Запуск emit_loop() [THREAD]

T=1.5s:  Открытие браузера

T=1s+:   Работа системы:
         ├─ Каждую секунду:
         │   ├─ evaluation_loop: оценка арбитража
         │   ├─ exchange_workers: получение котировок с бирж
         │   ├─ process_quotes_worker: обработка котировок
         │   └─ emit_loop: отправка обновлений через WebSocket
         │
         └─ Каждые 5 минут:
             └─ discovery_loop: обновление списка рынков
```

---

## 📝 Ключевые моменты

### Блокирующие операции:
1. **Очистка порта** - блокирует запуск до освобождения порта
2. **Первичная загрузка рынков** - блокирует до получения данных
3. **Первичная загрузка комиссий** - блокирует до получения данных

### Неблокирующие операции:
1. **Все циклы** - работают асинхронно, не блокируют друг друга
2. **Обработка котировок** - пакетная обработка с освобождением event loop
3. **Уведомления** - таймаут 0.5 секунды, не блокируют основной цикл

### Параллельность:
1. **Все биржи** - работают параллельно в отдельных задачах
2. **MEXC** - работает в отдельном потоке для изоляции
3. **Flask** - работает в отдельном потоке
4. **WebSocket emit** - работает в отдельном потоке Flask-SocketIO

### Архитектура QuoteStore (устранение блокировок):
1. **Два словаря:** `_quotes_write` (для записи) и `_quotes_read` (для чтения)
2. **Атомарное переключение:** после записи батча котировок, `_quotes_read` обновляется атомарно
3. **Чтение БЕЗ блокировки записи:** `list()` читает из `_quotes_read` без lock'а
4. **Запись не блокирует чтение:** `upsert_batch()` пишет в `_quotes_write`, затем быстро переключает

### Ограничения производительности:
1. **Размер пакета обработки** - максимум 1000 котировок за такт
2. **MEXC котировки** - обрабатываются все 935 нужных котировок из 2348 тикеров, которые возвращает API
3. **Таймауты** - для предотвращения блокировок при чтении (0.1 сек для `list()`)
4. **БЕЗ ограничений по времени** - обработка идет максимально быстро
5. **MEXC API** - возвращает все тикеры биржи (2348), но мы фильтруем только нужные (935)

---

## 🛑 Остановка системы

### Graceful shutdown:

1. **Получение сигнала** (SIGINT/SIGTERM)
   - Устанавливается `_stop_event`

2. **Остановка всех задач:**
   - Отменяются все asyncio задачи
   - Останавливается `aggregator`
   - Закрывается `notifier`

3. **Ожидание завершения:**
   - `asyncio.gather(*tasks, return_exceptions=True)`

4. **Закрытие ресурсов:**
   - Закрываются все адаптеры
   - Закрывается `http_factory`

5. **Завершение работы**

---

## 📊 Статистика параллельности

- **Asyncio задач:** ~8-12 (зависит от количества бирж)
  - 1 evaluation_loop
  - 1 discovery_loop
  - 1 flask_server
  - 1 transfer_mexc_quotes (если есть MEXC)
  - 1 process_quotes_worker
  - N exchange_workers (по одной на биржу)

- **Потоков:** 2-3
  - 1 Flask-SocketIO server
  - 1 Flask-SocketIO emit_loop
  - 1 MEXC worker (если есть MEXC)

- **Очередей:**
  - 1 asyncio.Queue для котировок (maxsize=10000)
  - 1 threading.Queue для MEXC (maxsize=5000, если есть MEXC)

---

## 🔍 Отладка

### Логирование:
- Каждый модуль имеет свой логгер
- Уровни логирования настраиваются в конфигурации
- Основной логгер: `arbitrage_bot.system`

### Ключевые метрики:
- Количество обработанных котировок
- Количество найденных арбитражных возможностей
- Статус подключения к биржам
- Время обработки пакетов

---

*Документ создан на основе анализа кода системы Arbitrage Bot*

